# game_engine.py

class GameEngine:
    def __init__(self, notes, tolerance=0.2):
        """
        Initialize the game engine with a sequence of notes and a timing tolerance.

        Parameters:
            notes (list): List of notes generated by note_creator.
            tolerance (float): Time tolerance to register a note hit.
        """
        self.notes = notes
        self.tolerance = tolerance
        self.score = 0
        self.current_note_index = 0  # Track the next note to be played
        self.game_active = False

    def start_game(self):
        """Start the game and initialize the score."""
        self.score = 0
        self.current_note_index = 0
        self.game_active = True
        print("Game started")

    def register_note_hit(self, hit_time, lane):
        """
        Register if the note was hit or missed based on timing accuracy.

        Parameters:
            hit_time (float): The time when the note was hit.
            lane (int): The lane where the note was hit.

        Returns:
            str: Result of the hit ('hit', 'miss').
        """
        if self.current_note_index >= len(self.notes):
            print("Debug: No more notes to hit.")
            return "miss"

        current_note = self.notes[self.current_note_index]
        timing_accuracy = abs(hit_time - current_note["time"])

        # Debug information to trace values during tests
        print(f"Debug: hit_time={hit_time}, note_time={current_note['time']}, lane={lane}, "
              f"note_lane={current_note['lane']}, timing_accuracy={timing_accuracy}, "
              f"tolerance={self.tolerance}")

        # Check for hit within tolerance
        if lane == current_note["lane"] and timing_accuracy <= self.tolerance:
            self.score += 100  # Adding score for each successful hit
            self.current_note_index += 1  # Move to the next note
            return "hit"
        
        # Miss condition without advancing the note index
        return "miss"

    def calculate_score(self):
        """Calculate and return the current score."""
        return self.score

    def end_game(self):
        """End the game and print the final score."""
        self.game_active = False
        print(f"Game over! Final score: {self.score}")
